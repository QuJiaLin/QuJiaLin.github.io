(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{347:function(t,a,n){"use strict";n.r(a);var s=n(3),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"canvas绘制路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#canvas绘制路径"}},[t._v("#")]),t._v(" canvas绘制路径")]),t._v(" "),a("p",[t._v("​\t图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。\n​")]),t._v(" "),a("h2",{attrs:{id:"步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[t._v("#")]),t._v(" 步骤")]),t._v(" "),a("p",[t._v("​\t1.首先，你需要创建路径起始点。\n​\t2.然后你使用画图命令去画出路径\n​\t3.之后你把路径封闭。\n​\t4.一旦路径生成，你就能通过描边或填充路径区域来渲染图形。\n​")]),t._v(" "),a("h2",{attrs:{id:"绘制三角形"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绘制三角形"}},[t._v("#")]),t._v(" 绘制三角形")]),t._v(" "),a("p",[t._v("​\tbeginPath()\n​\t\t新建一条路径，生成之后，图形绘制命令被指向到路径上准备生成路径。\n​")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("\t生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，\n\t所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，\n\t然后我们就可以重新绘制新的图形。\n\nmoveTo(x, y)\n\t将笔触移动到指定的坐标x以及y上\n\t当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点\n\t\nlineTo(x, y)\n\t将笔触移动到指定的坐标x以及y上\n\t绘制一条从当前位置到指定x以及y位置的直线。\n\nclosePath()\n\t闭合路径之后图形绘制命令又重新指向到上下文中。\n\t\t闭合路径closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。\n\t如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做\n\t\t当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。\n\t但是调用stroke()时不会自动闭合\n\t\nstroke()\n\t通过线条来绘制图形轮廓。\n\t不会自动调用closePath()\n\t\nfill()\n\t通过填充路径的内容区域生成实心的图形。\n\t自动调用closePath()\n")])])]),a("h2",{attrs:{id:"绘制矩形"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绘制矩形"}},[t._v("#")]),t._v(" 绘制矩形")]),t._v(" "),a("p",[t._v("​\trect(x, y, width, height)\n​\t\t绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。\n​\t\t当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。\n​\t\t也就是说，当前笔触自动重置会默认坐标\n​")]),t._v(" "),a("h2",{attrs:{id:"linecap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linecap"}},[t._v("#")]),t._v(" lineCap")]),t._v(" "),a("p",[t._v("​\tlineCap 是 Canvas 2D API 指定如何绘制每一条线段末端的属性。\n​\t有3个可能的值，分别是：\n​\t\tbutt  :线段末端以方形结束。\n​\t\tround :线段末端以圆形结束\n​\t\tsquare:线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域\n​\t默认值是 butt。\n​")]),t._v(" "),a("h2",{attrs:{id:"save"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[t._v("#")]),t._v(" save")]),t._v(" "),a("p",[t._v("​\tsave() 是 Canvas 2D API 通过将当前状态放入栈中，保存 canvas 全部状态的方法\n​")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("保存到栈中的绘制状态有下面部分组成：\n\t当前的变换矩阵。\n\t当前的剪切区域。\n\t当前的虚线列表.\n\t以下属性当前的值： strokeStyle, \n\t\t\t\t fillStyle,  \n\t\t\t\t lineWidth, \n\t\t\t\t lineCap, \n\t\t\t\t lineJoin...\n")])])]),a("h2",{attrs:{id:"restore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#restore"}},[t._v("#")]),t._v(" restore")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("restore() 是 Canvas 2D API 通过在绘图状态栈中弹出顶端的状态，将 canvas 恢复到最近的保存状态的方法。 \n如果没有保存状态，此方法不做任何改变。\t\n")])])]),a("p",[t._v("​\t\t\n​\t\t\n​")])])}),[],!1,null,null,null);a.default=e.exports}}]);