(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{348:function(t,n,e){"use strict";e.r(n);var s=e(3),i=Object(s.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"canvas绘制矩形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#canvas绘制矩形"}},[this._v("#")]),this._v(" canvas绘制矩形")]),this._v(" "),t("p",[this._v("​\tHTML中的元素canvas只支持一种原生的图形绘制：矩形。所有其他的图形的绘制都至少需要生成一条路径")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[this._v("1.绘制矩形\n\tcanvas提供了三种方法绘制矩形：\n\t\t----\x3e绘制一个填充的矩形（填充色默认为黑色）\n\t\t\tfillRect(x, y, width, height)\n\t\t----\x3e绘制一个矩形的边框（默认边框为:一像素实心黑色）\n\t\t\tstrokeRect(x, y, width, height)\n\t\t----\x3e清除指定矩形区域，让清除部分完全透明。\t\n\t\t\tclearRect(x, y, width, height)\n\t\t\t\n\tx与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。\n\twidth和height设置矩形的尺寸。（存在边框的话，边框会在width上占据一个边框的宽度，height同理）\n\n2.strokeRect时，边框像素渲染问题\n\t按理渲染出的边框应该是1px的，\n\tcanvas在渲染矩形边框时，边框宽度是平均分在偏移位置的两侧。\n\t\tcontext.strokeRect(10,10,50,50)\n\t\t\t:边框会渲染在10.5 和 9.5之间,浏览器是不会让一个像素只用自己的一半的\n\t\t\t  相当于边框会渲染在9到11之间\n\t\tcontext.strokeRect(10.5,10.5,50,50)\n\t\t\t:边框会渲染在10到11之间\n\n3.添加样式和颜色\n\tfillStyle   :设置图形的填充颜色。\n\tstrokeStyle :设置图形轮廓的颜色。\n\t\t默认情况下，线条和填充颜色都是黑色（CSS 颜色值 #000000）\n\tlineWidth : 这个属性设置当前绘线的粗细。属性值必须为正数。\n\t\t描述线段宽度的数字。 0、 负数、 Infinity 和 NaN 会被忽略。\n\t\t默认值是1.0。\n\t\t\n4.lineWidth & 覆盖渲染\n\n5.lineJoin\n\t设定线条与线条间接合处的样式（默认是 miter）\n\tround : 圆角\n\tbevel : 斜角\n\tmiter : 直角\n")])])]),t("p",[this._v("​\t\t\n​")])])}),[],!1,null,null,null);n.default=i.exports}}]);